// automatically generated by the FlatBuffers compiler, do not modify
// ADDED BY HAND TO ELIMINATE NOISE
#![allow(dead_code, unused_imports, clippy::all)]


use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod gen_events {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EVENT_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EVENT_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EVENT_TYPE: [EventType; 11] = [
  EventType::NONE,
  EventType::NewImageEvent,
  EventType::ImageReceivedEvent,
  EventType::ImageScoredEvent,
  EventType::ImageStoredEvent,
  EventType::ImageDeletedEvent,
  EventType::PluginStartedEvent,
  EventType::PluginTerminatingEvent,
  EventType::PluginTerminateEvent,
  EventType::MonitorPowerStartEvent,
  EventType::MonitorPowerStopEvent,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EventType(pub u8);
#[allow(non_upper_case_globals)]
impl EventType {
  pub const NONE: Self = Self(0);
  pub const NewImageEvent: Self = Self(1);
  pub const ImageReceivedEvent: Self = Self(2);
  pub const ImageScoredEvent: Self = Self(3);
  pub const ImageStoredEvent: Self = Self(4);
  pub const ImageDeletedEvent: Self = Self(5);
  pub const PluginStartedEvent: Self = Self(6);
  pub const PluginTerminatingEvent: Self = Self(7);
  pub const PluginTerminateEvent: Self = Self(8);
  pub const MonitorPowerStartEvent: Self = Self(9);
  pub const MonitorPowerStopEvent: Self = Self(10);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::NewImageEvent,
    Self::ImageReceivedEvent,
    Self::ImageScoredEvent,
    Self::ImageStoredEvent,
    Self::ImageDeletedEvent,
    Self::PluginStartedEvent,
    Self::PluginTerminatingEvent,
    Self::PluginTerminateEvent,
    Self::MonitorPowerStartEvent,
    Self::MonitorPowerStopEvent,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::NewImageEvent => Some("NewImageEvent"),
      Self::ImageReceivedEvent => Some("ImageReceivedEvent"),
      Self::ImageScoredEvent => Some("ImageScoredEvent"),
      Self::ImageStoredEvent => Some("ImageStoredEvent"),
      Self::ImageDeletedEvent => Some("ImageDeletedEvent"),
      Self::PluginStartedEvent => Some("PluginStartedEvent"),
      Self::PluginTerminatingEvent => Some("PluginTerminatingEvent"),
      Self::PluginTerminateEvent => Some("PluginTerminateEvent"),
      Self::MonitorPowerStartEvent => Some("MonitorPowerStartEvent"),
      Self::MonitorPowerStopEvent => Some("MonitorPowerStopEvent"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for EventType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for EventType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for EventType {
    type Output = EventType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for EventType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for EventType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for EventType {}
pub struct EventTypeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MONITOR_TYPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MONITOR_TYPE: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MONITOR_TYPE: [MonitorType; 4] = [
  MonitorType::ALL,
  MonitorType::CPU,
  MonitorType::GPU,
  MonitorType::DRAM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MonitorType(pub i8);
#[allow(non_upper_case_globals)]
impl MonitorType {
  pub const ALL: Self = Self(1);
  pub const CPU: Self = Self(2);
  pub const GPU: Self = Self(3);
  pub const DRAM: Self = Self(4);

  pub const ENUM_MIN: i8 = 1;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ALL,
    Self::CPU,
    Self::GPU,
    Self::DRAM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ALL => Some("ALL"),
      Self::CPU => Some("CPU"),
      Self::GPU => Some("GPU"),
      Self::DRAM => Some("DRAM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MonitorType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MonitorType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for MonitorType {
    type Output = MonitorType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for MonitorType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MonitorType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MonitorType {}
pub enum NewImageEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NewImageEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NewImageEvent<'a> {
  type Inner = NewImageEvent<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> NewImageEvent<'a> {
  pub const VT_EVENT_CREATE_TS: flatbuffers::VOffsetT = 4;
  pub const VT_IMAGE_UUID: flatbuffers::VOffsetT = 6;
  pub const VT_IMAGE_FORMAT: flatbuffers::VOffsetT = 8;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NewImageEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args NewImageEventArgs<'args>
  ) -> flatbuffers::WIPOffset<NewImageEvent<'bldr>> {
    let mut builder = NewImageEventBuilder::new(_fbb);
    if let Some(x) = args.image { builder.add_image(x); }
    if let Some(x) = args.image_format { builder.add_image_format(x); }
    if let Some(x) = args.image_uuid { builder.add_image_uuid(x); }
    if let Some(x) = args.event_create_ts { builder.add_event_create_ts(x); }
    builder.finish()
  }


  #[inline]
  pub fn event_create_ts(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NewImageEvent::VT_EVENT_CREATE_TS, None)
  }
  #[inline]
  pub fn image_uuid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NewImageEvent::VT_IMAGE_UUID, None)
  }
  #[inline]
  pub fn image_format(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NewImageEvent::VT_IMAGE_FORMAT, None)
  }
  #[inline]
  pub fn image(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(NewImageEvent::VT_IMAGE, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for NewImageEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_create_ts", Self::VT_EVENT_CREATE_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image_uuid", Self::VT_IMAGE_UUID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image_format", Self::VT_IMAGE_FORMAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("image", Self::VT_IMAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct NewImageEventArgs<'a> {
    pub event_create_ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image_uuid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image_format: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for NewImageEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    NewImageEventArgs {
      event_create_ts: None,
      image_uuid: None,
      image_format: None,
      image: None,
    }
  }
}

pub struct NewImageEventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NewImageEventBuilder<'a, 'b> {
  #[inline]
  pub fn add_event_create_ts(&mut self, event_create_ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NewImageEvent::VT_EVENT_CREATE_TS, event_create_ts);
  }
  #[inline]
  pub fn add_image_uuid(&mut self, image_uuid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NewImageEvent::VT_IMAGE_UUID, image_uuid);
  }
  #[inline]
  pub fn add_image_format(&mut self, image_format: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NewImageEvent::VT_IMAGE_FORMAT, image_format);
  }
  #[inline]
  pub fn add_image(&mut self, image: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NewImageEvent::VT_IMAGE, image);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NewImageEventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NewImageEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NewImageEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NewImageEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NewImageEvent");
      ds.field("event_create_ts", &self.event_create_ts());
      ds.field("image_uuid", &self.image_uuid());
      ds.field("image_format", &self.image_format());
      ds.field("image", &self.image());
      ds.finish()
  }
}
pub enum ImageReceivedEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ImageReceivedEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ImageReceivedEvent<'a> {
  type Inner = ImageReceivedEvent<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ImageReceivedEvent<'a> {
  pub const VT_EVENT_CREATE_TS: flatbuffers::VOffsetT = 4;
  pub const VT_IMAGE_UUID: flatbuffers::VOffsetT = 6;
  pub const VT_IMAGE_FORMAT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ImageReceivedEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ImageReceivedEventArgs<'args>
  ) -> flatbuffers::WIPOffset<ImageReceivedEvent<'bldr>> {
    let mut builder = ImageReceivedEventBuilder::new(_fbb);
    if let Some(x) = args.image_format { builder.add_image_format(x); }
    if let Some(x) = args.image_uuid { builder.add_image_uuid(x); }
    if let Some(x) = args.event_create_ts { builder.add_event_create_ts(x); }
    builder.finish()
  }


  #[inline]
  pub fn event_create_ts(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageReceivedEvent::VT_EVENT_CREATE_TS, None)
  }
  #[inline]
  pub fn image_uuid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageReceivedEvent::VT_IMAGE_UUID, None)
  }
  #[inline]
  pub fn image_format(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageReceivedEvent::VT_IMAGE_FORMAT, None)
  }
}

impl flatbuffers::Verifiable for ImageReceivedEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_create_ts", Self::VT_EVENT_CREATE_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image_uuid", Self::VT_IMAGE_UUID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image_format", Self::VT_IMAGE_FORMAT, false)?
     .finish();
    Ok(())
  }
}
pub struct ImageReceivedEventArgs<'a> {
    pub event_create_ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image_uuid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image_format: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ImageReceivedEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    ImageReceivedEventArgs {
      event_create_ts: None,
      image_uuid: None,
      image_format: None,
    }
  }
}

pub struct ImageReceivedEventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ImageReceivedEventBuilder<'a, 'b> {
  #[inline]
  pub fn add_event_create_ts(&mut self, event_create_ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageReceivedEvent::VT_EVENT_CREATE_TS, event_create_ts);
  }
  #[inline]
  pub fn add_image_uuid(&mut self, image_uuid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageReceivedEvent::VT_IMAGE_UUID, image_uuid);
  }
  #[inline]
  pub fn add_image_format(&mut self, image_format: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageReceivedEvent::VT_IMAGE_FORMAT, image_format);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ImageReceivedEventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ImageReceivedEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ImageReceivedEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ImageReceivedEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ImageReceivedEvent");
      ds.field("event_create_ts", &self.event_create_ts());
      ds.field("image_uuid", &self.image_uuid());
      ds.field("image_format", &self.image_format());
      ds.finish()
  }
}
pub enum ImageLabelScoreOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ImageLabelScore<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ImageLabelScore<'a> {
  type Inner = ImageLabelScore<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ImageLabelScore<'a> {
  pub const VT_LABEL: flatbuffers::VOffsetT = 4;
  pub const VT_PROBABILITY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ImageLabelScore { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ImageLabelScoreArgs<'args>
  ) -> flatbuffers::WIPOffset<ImageLabelScore<'bldr>> {
    let mut builder = ImageLabelScoreBuilder::new(_fbb);
    builder.add_probability(args.probability);
    if let Some(x) = args.label { builder.add_label(x); }
    builder.finish()
  }


  #[inline]
  pub fn label(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageLabelScore::VT_LABEL, None)
  }
  #[inline]
  pub fn probability(&self) -> f32 {
    self._tab.get::<f32>(ImageLabelScore::VT_PROBABILITY, Some(0.0)).unwrap()
  }
}

impl flatbuffers::Verifiable for ImageLabelScore<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
     .visit_field::<f32>("probability", Self::VT_PROBABILITY, false)?
     .finish();
    Ok(())
  }
}
pub struct ImageLabelScoreArgs<'a> {
    pub label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub probability: f32,
}
impl<'a> Default for ImageLabelScoreArgs<'a> {
  #[inline]
  fn default() -> Self {
    ImageLabelScoreArgs {
      label: None,
      probability: 0.0,
    }
  }
}

pub struct ImageLabelScoreBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ImageLabelScoreBuilder<'a, 'b> {
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageLabelScore::VT_LABEL, label);
  }
  #[inline]
  pub fn add_probability(&mut self, probability: f32) {
    self.fbb_.push_slot::<f32>(ImageLabelScore::VT_PROBABILITY, probability, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ImageLabelScoreBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ImageLabelScoreBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ImageLabelScore<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ImageLabelScore<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ImageLabelScore");
      ds.field("label", &self.label());
      ds.field("probability", &self.probability());
      ds.finish()
  }
}
pub enum ImageScoredEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ImageScoredEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ImageScoredEvent<'a> {
  type Inner = ImageScoredEvent<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ImageScoredEvent<'a> {
  pub const VT_EVENT_CREATE_TS: flatbuffers::VOffsetT = 4;
  pub const VT_IMAGE_UUID: flatbuffers::VOffsetT = 6;
  pub const VT_IMAGE_FORMAT: flatbuffers::VOffsetT = 8;
  pub const VT_SCORES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ImageScoredEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ImageScoredEventArgs<'args>
  ) -> flatbuffers::WIPOffset<ImageScoredEvent<'bldr>> {
    let mut builder = ImageScoredEventBuilder::new(_fbb);
    if let Some(x) = args.scores { builder.add_scores(x); }
    if let Some(x) = args.image_format { builder.add_image_format(x); }
    if let Some(x) = args.image_uuid { builder.add_image_uuid(x); }
    if let Some(x) = args.event_create_ts { builder.add_event_create_ts(x); }
    builder.finish()
  }


  #[inline]
  pub fn event_create_ts(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageScoredEvent::VT_EVENT_CREATE_TS, None)
  }
  #[inline]
  pub fn image_uuid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageScoredEvent::VT_IMAGE_UUID, None)
  }
  #[inline]
  pub fn image_format(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageScoredEvent::VT_IMAGE_FORMAT, None)
  }
  #[inline]
  pub fn scores(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ImageLabelScore<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ImageLabelScore>>>>(ImageScoredEvent::VT_SCORES, None)
  }
}

impl flatbuffers::Verifiable for ImageScoredEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_create_ts", Self::VT_EVENT_CREATE_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image_uuid", Self::VT_IMAGE_UUID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image_format", Self::VT_IMAGE_FORMAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ImageLabelScore>>>>("scores", Self::VT_SCORES, false)?
     .finish();
    Ok(())
  }
}
pub struct ImageScoredEventArgs<'a> {
    pub event_create_ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image_uuid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image_format: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scores: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ImageLabelScore<'a>>>>>,
}
impl<'a> Default for ImageScoredEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    ImageScoredEventArgs {
      event_create_ts: None,
      image_uuid: None,
      image_format: None,
      scores: None,
    }
  }
}

pub struct ImageScoredEventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ImageScoredEventBuilder<'a, 'b> {
  #[inline]
  pub fn add_event_create_ts(&mut self, event_create_ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageScoredEvent::VT_EVENT_CREATE_TS, event_create_ts);
  }
  #[inline]
  pub fn add_image_uuid(&mut self, image_uuid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageScoredEvent::VT_IMAGE_UUID, image_uuid);
  }
  #[inline]
  pub fn add_image_format(&mut self, image_format: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageScoredEvent::VT_IMAGE_FORMAT, image_format);
  }
  #[inline]
  pub fn add_scores(&mut self, scores: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ImageLabelScore<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageScoredEvent::VT_SCORES, scores);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ImageScoredEventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ImageScoredEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ImageScoredEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ImageScoredEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ImageScoredEvent");
      ds.field("event_create_ts", &self.event_create_ts());
      ds.field("image_uuid", &self.image_uuid());
      ds.field("image_format", &self.image_format());
      ds.field("scores", &self.scores());
      ds.finish()
  }
}
pub enum ImageStoredEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ImageStoredEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ImageStoredEvent<'a> {
  type Inner = ImageStoredEvent<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ImageStoredEvent<'a> {
  pub const VT_EVENT_CREATE_TS: flatbuffers::VOffsetT = 4;
  pub const VT_IMAGE_UUID: flatbuffers::VOffsetT = 6;
  pub const VT_IMAGE_FORMAT: flatbuffers::VOffsetT = 8;
  pub const VT_DESTINATION: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ImageStoredEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ImageStoredEventArgs<'args>
  ) -> flatbuffers::WIPOffset<ImageStoredEvent<'bldr>> {
    let mut builder = ImageStoredEventBuilder::new(_fbb);
    if let Some(x) = args.destination { builder.add_destination(x); }
    if let Some(x) = args.image_format { builder.add_image_format(x); }
    if let Some(x) = args.image_uuid { builder.add_image_uuid(x); }
    if let Some(x) = args.event_create_ts { builder.add_event_create_ts(x); }
    builder.finish()
  }


  #[inline]
  pub fn event_create_ts(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageStoredEvent::VT_EVENT_CREATE_TS, None)
  }
  #[inline]
  pub fn image_uuid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageStoredEvent::VT_IMAGE_UUID, None)
  }
  #[inline]
  pub fn image_format(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageStoredEvent::VT_IMAGE_FORMAT, None)
  }
  #[inline]
  pub fn destination(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageStoredEvent::VT_DESTINATION, None)
  }
}

impl flatbuffers::Verifiable for ImageStoredEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_create_ts", Self::VT_EVENT_CREATE_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image_uuid", Self::VT_IMAGE_UUID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image_format", Self::VT_IMAGE_FORMAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("destination", Self::VT_DESTINATION, false)?
     .finish();
    Ok(())
  }
}
pub struct ImageStoredEventArgs<'a> {
    pub event_create_ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image_uuid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image_format: Option<flatbuffers::WIPOffset<&'a str>>,
    pub destination: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ImageStoredEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    ImageStoredEventArgs {
      event_create_ts: None,
      image_uuid: None,
      image_format: None,
      destination: None,
    }
  }
}

pub struct ImageStoredEventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ImageStoredEventBuilder<'a, 'b> {
  #[inline]
  pub fn add_event_create_ts(&mut self, event_create_ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageStoredEvent::VT_EVENT_CREATE_TS, event_create_ts);
  }
  #[inline]
  pub fn add_image_uuid(&mut self, image_uuid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageStoredEvent::VT_IMAGE_UUID, image_uuid);
  }
  #[inline]
  pub fn add_image_format(&mut self, image_format: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageStoredEvent::VT_IMAGE_FORMAT, image_format);
  }
  #[inline]
  pub fn add_destination(&mut self, destination: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageStoredEvent::VT_DESTINATION, destination);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ImageStoredEventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ImageStoredEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ImageStoredEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ImageStoredEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ImageStoredEvent");
      ds.field("event_create_ts", &self.event_create_ts());
      ds.field("image_uuid", &self.image_uuid());
      ds.field("image_format", &self.image_format());
      ds.field("destination", &self.destination());
      ds.finish()
  }
}
pub enum ImageDeletedEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ImageDeletedEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ImageDeletedEvent<'a> {
  type Inner = ImageDeletedEvent<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ImageDeletedEvent<'a> {
  pub const VT_EVENT_CREATE_TS: flatbuffers::VOffsetT = 4;
  pub const VT_IMAGE_UUID: flatbuffers::VOffsetT = 6;
  pub const VT_IMAGE_FORMAT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ImageDeletedEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ImageDeletedEventArgs<'args>
  ) -> flatbuffers::WIPOffset<ImageDeletedEvent<'bldr>> {
    let mut builder = ImageDeletedEventBuilder::new(_fbb);
    if let Some(x) = args.image_format { builder.add_image_format(x); }
    if let Some(x) = args.image_uuid { builder.add_image_uuid(x); }
    if let Some(x) = args.event_create_ts { builder.add_event_create_ts(x); }
    builder.finish()
  }


  #[inline]
  pub fn event_create_ts(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageDeletedEvent::VT_EVENT_CREATE_TS, None)
  }
  #[inline]
  pub fn image_uuid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageDeletedEvent::VT_IMAGE_UUID, None)
  }
  #[inline]
  pub fn image_format(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ImageDeletedEvent::VT_IMAGE_FORMAT, None)
  }
}

impl flatbuffers::Verifiable for ImageDeletedEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_create_ts", Self::VT_EVENT_CREATE_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image_uuid", Self::VT_IMAGE_UUID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image_format", Self::VT_IMAGE_FORMAT, false)?
     .finish();
    Ok(())
  }
}
pub struct ImageDeletedEventArgs<'a> {
    pub event_create_ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image_uuid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image_format: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ImageDeletedEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    ImageDeletedEventArgs {
      event_create_ts: None,
      image_uuid: None,
      image_format: None,
    }
  }
}

pub struct ImageDeletedEventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ImageDeletedEventBuilder<'a, 'b> {
  #[inline]
  pub fn add_event_create_ts(&mut self, event_create_ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageDeletedEvent::VT_EVENT_CREATE_TS, event_create_ts);
  }
  #[inline]
  pub fn add_image_uuid(&mut self, image_uuid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageDeletedEvent::VT_IMAGE_UUID, image_uuid);
  }
  #[inline]
  pub fn add_image_format(&mut self, image_format: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ImageDeletedEvent::VT_IMAGE_FORMAT, image_format);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ImageDeletedEventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ImageDeletedEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ImageDeletedEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ImageDeletedEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ImageDeletedEvent");
      ds.field("event_create_ts", &self.event_create_ts());
      ds.field("image_uuid", &self.image_uuid());
      ds.field("image_format", &self.image_format());
      ds.finish()
  }
}
pub enum PluginStartedEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PluginStartedEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PluginStartedEvent<'a> {
  type Inner = PluginStartedEvent<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> PluginStartedEvent<'a> {
  pub const VT_EVENT_CREATE_TS: flatbuffers::VOffsetT = 4;
  pub const VT_PLUGIN_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_PLUGIN_UUID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PluginStartedEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PluginStartedEventArgs<'args>
  ) -> flatbuffers::WIPOffset<PluginStartedEvent<'bldr>> {
    let mut builder = PluginStartedEventBuilder::new(_fbb);
    if let Some(x) = args.plugin_uuid { builder.add_plugin_uuid(x); }
    if let Some(x) = args.plugin_name { builder.add_plugin_name(x); }
    if let Some(x) = args.event_create_ts { builder.add_event_create_ts(x); }
    builder.finish()
  }


  #[inline]
  pub fn event_create_ts(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginStartedEvent::VT_EVENT_CREATE_TS, None)
  }
  #[inline]
  pub fn plugin_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginStartedEvent::VT_PLUGIN_NAME, None)
  }
  #[inline]
  pub fn plugin_uuid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginStartedEvent::VT_PLUGIN_UUID, None)
  }
}

impl flatbuffers::Verifiable for PluginStartedEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_create_ts", Self::VT_EVENT_CREATE_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("plugin_name", Self::VT_PLUGIN_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("plugin_uuid", Self::VT_PLUGIN_UUID, false)?
     .finish();
    Ok(())
  }
}
pub struct PluginStartedEventArgs<'a> {
    pub event_create_ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub plugin_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub plugin_uuid: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PluginStartedEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    PluginStartedEventArgs {
      event_create_ts: None,
      plugin_name: None,
      plugin_uuid: None,
    }
  }
}

pub struct PluginStartedEventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PluginStartedEventBuilder<'a, 'b> {
  #[inline]
  pub fn add_event_create_ts(&mut self, event_create_ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginStartedEvent::VT_EVENT_CREATE_TS, event_create_ts);
  }
  #[inline]
  pub fn add_plugin_name(&mut self, plugin_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginStartedEvent::VT_PLUGIN_NAME, plugin_name);
  }
  #[inline]
  pub fn add_plugin_uuid(&mut self, plugin_uuid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginStartedEvent::VT_PLUGIN_UUID, plugin_uuid);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PluginStartedEventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PluginStartedEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PluginStartedEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PluginStartedEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PluginStartedEvent");
      ds.field("event_create_ts", &self.event_create_ts());
      ds.field("plugin_name", &self.plugin_name());
      ds.field("plugin_uuid", &self.plugin_uuid());
      ds.finish()
  }
}
pub enum PluginTerminatingEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PluginTerminatingEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PluginTerminatingEvent<'a> {
  type Inner = PluginTerminatingEvent<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> PluginTerminatingEvent<'a> {
  pub const VT_EVENT_CREATE_TS: flatbuffers::VOffsetT = 4;
  pub const VT_PLUGIN_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_PLUGIN_UUID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PluginTerminatingEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PluginTerminatingEventArgs<'args>
  ) -> flatbuffers::WIPOffset<PluginTerminatingEvent<'bldr>> {
    let mut builder = PluginTerminatingEventBuilder::new(_fbb);
    if let Some(x) = args.plugin_uuid { builder.add_plugin_uuid(x); }
    if let Some(x) = args.plugin_name { builder.add_plugin_name(x); }
    if let Some(x) = args.event_create_ts { builder.add_event_create_ts(x); }
    builder.finish()
  }


  #[inline]
  pub fn event_create_ts(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginTerminatingEvent::VT_EVENT_CREATE_TS, None)
  }
  #[inline]
  pub fn plugin_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginTerminatingEvent::VT_PLUGIN_NAME, None)
  }
  #[inline]
  pub fn plugin_uuid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginTerminatingEvent::VT_PLUGIN_UUID, None)
  }
}

impl flatbuffers::Verifiable for PluginTerminatingEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_create_ts", Self::VT_EVENT_CREATE_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("plugin_name", Self::VT_PLUGIN_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("plugin_uuid", Self::VT_PLUGIN_UUID, false)?
     .finish();
    Ok(())
  }
}
pub struct PluginTerminatingEventArgs<'a> {
    pub event_create_ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub plugin_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub plugin_uuid: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PluginTerminatingEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    PluginTerminatingEventArgs {
      event_create_ts: None,
      plugin_name: None,
      plugin_uuid: None,
    }
  }
}

pub struct PluginTerminatingEventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PluginTerminatingEventBuilder<'a, 'b> {
  #[inline]
  pub fn add_event_create_ts(&mut self, event_create_ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginTerminatingEvent::VT_EVENT_CREATE_TS, event_create_ts);
  }
  #[inline]
  pub fn add_plugin_name(&mut self, plugin_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginTerminatingEvent::VT_PLUGIN_NAME, plugin_name);
  }
  #[inline]
  pub fn add_plugin_uuid(&mut self, plugin_uuid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginTerminatingEvent::VT_PLUGIN_UUID, plugin_uuid);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PluginTerminatingEventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PluginTerminatingEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PluginTerminatingEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PluginTerminatingEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PluginTerminatingEvent");
      ds.field("event_create_ts", &self.event_create_ts());
      ds.field("plugin_name", &self.plugin_name());
      ds.field("plugin_uuid", &self.plugin_uuid());
      ds.finish()
  }
}
pub enum PluginTerminateEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PluginTerminateEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PluginTerminateEvent<'a> {
  type Inner = PluginTerminateEvent<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> PluginTerminateEvent<'a> {
  pub const VT_EVENT_CREATE_TS: flatbuffers::VOffsetT = 4;
  pub const VT_TARGET_PLUGIN_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_TARGET_PLUGIN_UUID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PluginTerminateEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PluginTerminateEventArgs<'args>
  ) -> flatbuffers::WIPOffset<PluginTerminateEvent<'bldr>> {
    let mut builder = PluginTerminateEventBuilder::new(_fbb);
    if let Some(x) = args.target_plugin_uuid { builder.add_target_plugin_uuid(x); }
    if let Some(x) = args.target_plugin_name { builder.add_target_plugin_name(x); }
    if let Some(x) = args.event_create_ts { builder.add_event_create_ts(x); }
    builder.finish()
  }


  #[inline]
  pub fn event_create_ts(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginTerminateEvent::VT_EVENT_CREATE_TS, None)
  }
  #[inline]
  pub fn target_plugin_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginTerminateEvent::VT_TARGET_PLUGIN_NAME, None)
  }
  #[inline]
  pub fn target_plugin_uuid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginTerminateEvent::VT_TARGET_PLUGIN_UUID, None)
  }
}

impl flatbuffers::Verifiable for PluginTerminateEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_create_ts", Self::VT_EVENT_CREATE_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target_plugin_name", Self::VT_TARGET_PLUGIN_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target_plugin_uuid", Self::VT_TARGET_PLUGIN_UUID, false)?
     .finish();
    Ok(())
  }
}
pub struct PluginTerminateEventArgs<'a> {
    pub event_create_ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub target_plugin_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub target_plugin_uuid: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PluginTerminateEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    PluginTerminateEventArgs {
      event_create_ts: None,
      target_plugin_name: None,
      target_plugin_uuid: None,
    }
  }
}

pub struct PluginTerminateEventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PluginTerminateEventBuilder<'a, 'b> {
  #[inline]
  pub fn add_event_create_ts(&mut self, event_create_ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginTerminateEvent::VT_EVENT_CREATE_TS, event_create_ts);
  }
  #[inline]
  pub fn add_target_plugin_name(&mut self, target_plugin_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginTerminateEvent::VT_TARGET_PLUGIN_NAME, target_plugin_name);
  }
  #[inline]
  pub fn add_target_plugin_uuid(&mut self, target_plugin_uuid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginTerminateEvent::VT_TARGET_PLUGIN_UUID, target_plugin_uuid);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PluginTerminateEventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PluginTerminateEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PluginTerminateEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PluginTerminateEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PluginTerminateEvent");
      ds.field("event_create_ts", &self.event_create_ts());
      ds.field("target_plugin_name", &self.target_plugin_name());
      ds.field("target_plugin_uuid", &self.target_plugin_uuid());
      ds.finish()
  }
}
pub enum MonitorPowerStartEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MonitorPowerStartEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MonitorPowerStartEvent<'a> {
  type Inner = MonitorPowerStartEvent<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> MonitorPowerStartEvent<'a> {
  pub const VT_EVENT_CREATE_TS: flatbuffers::VOffsetT = 4;
  pub const VT_PIDS: flatbuffers::VOffsetT = 6;
  pub const VT_MONITOR_TYPES: flatbuffers::VOffsetT = 8;
  pub const VT_MONITOR_START_TS: flatbuffers::VOffsetT = 10;
  pub const VT_MONITOR_SECONDS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MonitorPowerStartEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MonitorPowerStartEventArgs<'args>
  ) -> flatbuffers::WIPOffset<MonitorPowerStartEvent<'bldr>> {
    let mut builder = MonitorPowerStartEventBuilder::new(_fbb);
    builder.add_monitor_seconds(args.monitor_seconds);
    if let Some(x) = args.monitor_start_ts { builder.add_monitor_start_ts(x); }
    if let Some(x) = args.monitor_types { builder.add_monitor_types(x); }
    if let Some(x) = args.pids { builder.add_pids(x); }
    if let Some(x) = args.event_create_ts { builder.add_event_create_ts(x); }
    builder.finish()
  }


  #[inline]
  pub fn event_create_ts(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MonitorPowerStartEvent::VT_EVENT_CREATE_TS, None)
  }
  #[inline]
  pub fn pids(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(MonitorPowerStartEvent::VT_PIDS, None)
  }
  #[inline]
  pub fn monitor_types(&self) -> Option<flatbuffers::Vector<'a, MonitorType>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, MonitorType>>>(MonitorPowerStartEvent::VT_MONITOR_TYPES, None)
  }
  #[inline]
  pub fn monitor_start_ts(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MonitorPowerStartEvent::VT_MONITOR_START_TS, None)
  }
  #[inline]
  pub fn monitor_seconds(&self) -> u32 {
    self._tab.get::<u32>(MonitorPowerStartEvent::VT_MONITOR_SECONDS, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for MonitorPowerStartEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_create_ts", Self::VT_EVENT_CREATE_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("pids", Self::VT_PIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, MonitorType>>>("monitor_types", Self::VT_MONITOR_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("monitor_start_ts", Self::VT_MONITOR_START_TS, false)?
     .visit_field::<u32>("monitor_seconds", Self::VT_MONITOR_SECONDS, false)?
     .finish();
    Ok(())
  }
}
pub struct MonitorPowerStartEventArgs<'a> {
    pub event_create_ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub monitor_types: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, MonitorType>>>,
    pub monitor_start_ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monitor_seconds: u32,
}
impl<'a> Default for MonitorPowerStartEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    MonitorPowerStartEventArgs {
      event_create_ts: None,
      pids: None,
      monitor_types: None,
      monitor_start_ts: None,
      monitor_seconds: 0,
    }
  }
}

pub struct MonitorPowerStartEventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MonitorPowerStartEventBuilder<'a, 'b> {
  #[inline]
  pub fn add_event_create_ts(&mut self, event_create_ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MonitorPowerStartEvent::VT_EVENT_CREATE_TS, event_create_ts);
  }
  #[inline]
  pub fn add_pids(&mut self, pids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MonitorPowerStartEvent::VT_PIDS, pids);
  }
  #[inline]
  pub fn add_monitor_types(&mut self, monitor_types: flatbuffers::WIPOffset<flatbuffers::Vector<'b , MonitorType>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MonitorPowerStartEvent::VT_MONITOR_TYPES, monitor_types);
  }
  #[inline]
  pub fn add_monitor_start_ts(&mut self, monitor_start_ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MonitorPowerStartEvent::VT_MONITOR_START_TS, monitor_start_ts);
  }
  #[inline]
  pub fn add_monitor_seconds(&mut self, monitor_seconds: u32) {
    self.fbb_.push_slot::<u32>(MonitorPowerStartEvent::VT_MONITOR_SECONDS, monitor_seconds, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MonitorPowerStartEventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MonitorPowerStartEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MonitorPowerStartEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MonitorPowerStartEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MonitorPowerStartEvent");
      ds.field("event_create_ts", &self.event_create_ts());
      ds.field("pids", &self.pids());
      ds.field("monitor_types", &self.monitor_types());
      ds.field("monitor_start_ts", &self.monitor_start_ts());
      ds.field("monitor_seconds", &self.monitor_seconds());
      ds.finish()
  }
}
pub enum MonitorPowerStopEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MonitorPowerStopEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MonitorPowerStopEvent<'a> {
  type Inner = MonitorPowerStopEvent<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> MonitorPowerStopEvent<'a> {
  pub const VT_EVENT_CREATE_TS: flatbuffers::VOffsetT = 4;
  pub const VT_PIDS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MonitorPowerStopEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MonitorPowerStopEventArgs<'args>
  ) -> flatbuffers::WIPOffset<MonitorPowerStopEvent<'bldr>> {
    let mut builder = MonitorPowerStopEventBuilder::new(_fbb);
    if let Some(x) = args.pids { builder.add_pids(x); }
    if let Some(x) = args.event_create_ts { builder.add_event_create_ts(x); }
    builder.finish()
  }


  #[inline]
  pub fn event_create_ts(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MonitorPowerStopEvent::VT_EVENT_CREATE_TS, None)
  }
  #[inline]
  pub fn pids(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(MonitorPowerStopEvent::VT_PIDS, None)
  }
}

impl flatbuffers::Verifiable for MonitorPowerStopEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("event_create_ts", Self::VT_EVENT_CREATE_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("pids", Self::VT_PIDS, false)?
     .finish();
    Ok(())
  }
}
pub struct MonitorPowerStopEventArgs<'a> {
    pub event_create_ts: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for MonitorPowerStopEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    MonitorPowerStopEventArgs {
      event_create_ts: None,
      pids: None,
    }
  }
}

pub struct MonitorPowerStopEventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MonitorPowerStopEventBuilder<'a, 'b> {
  #[inline]
  pub fn add_event_create_ts(&mut self, event_create_ts: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MonitorPowerStopEvent::VT_EVENT_CREATE_TS, event_create_ts);
  }
  #[inline]
  pub fn add_pids(&mut self, pids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MonitorPowerStopEvent::VT_PIDS, pids);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MonitorPowerStopEventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MonitorPowerStopEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MonitorPowerStopEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MonitorPowerStopEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MonitorPowerStopEvent");
      ds.field("event_create_ts", &self.event_create_ts());
      ds.field("pids", &self.pids());
      ds.finish()
  }
}
pub enum EventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Event<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Event<'a> {
  type Inner = Event<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Event<'a> {
  pub const VT_EVENT_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_EVENT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Event { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EventArgs
  ) -> flatbuffers::WIPOffset<Event<'bldr>> {
    let mut builder = EventBuilder::new(_fbb);
    if let Some(x) = args.event { builder.add_event(x); }
    builder.add_event_type(args.event_type);
    builder.finish()
  }


  #[inline]
  pub fn event_type(&self) -> EventType {
    self._tab.get::<EventType>(Event::VT_EVENT_TYPE, Some(EventType::NONE)).unwrap()
  }
  #[inline]
  pub fn event(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Event::VT_EVENT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_new_image_event(&self) -> Option<NewImageEvent<'a>> {
    if self.event_type() == EventType::NewImageEvent {
      self.event().map(NewImageEvent::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_image_received_event(&self) -> Option<ImageReceivedEvent<'a>> {
    if self.event_type() == EventType::ImageReceivedEvent {
      self.event().map(ImageReceivedEvent::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_image_scored_event(&self) -> Option<ImageScoredEvent<'a>> {
    if self.event_type() == EventType::ImageScoredEvent {
      self.event().map(ImageScoredEvent::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_image_stored_event(&self) -> Option<ImageStoredEvent<'a>> {
    if self.event_type() == EventType::ImageStoredEvent {
      self.event().map(ImageStoredEvent::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_image_deleted_event(&self) -> Option<ImageDeletedEvent<'a>> {
    if self.event_type() == EventType::ImageDeletedEvent {
      self.event().map(ImageDeletedEvent::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_plugin_started_event(&self) -> Option<PluginStartedEvent<'a>> {
    if self.event_type() == EventType::PluginStartedEvent {
      self.event().map(PluginStartedEvent::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_plugin_terminating_event(&self) -> Option<PluginTerminatingEvent<'a>> {
    if self.event_type() == EventType::PluginTerminatingEvent {
      self.event().map(PluginTerminatingEvent::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_plugin_terminate_event(&self) -> Option<PluginTerminateEvent<'a>> {
    if self.event_type() == EventType::PluginTerminateEvent {
      self.event().map(PluginTerminateEvent::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_monitor_power_start_event(&self) -> Option<MonitorPowerStartEvent<'a>> {
    if self.event_type() == EventType::MonitorPowerStartEvent {
      self.event().map(MonitorPowerStartEvent::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_monitor_power_stop_event(&self) -> Option<MonitorPowerStopEvent<'a>> {
    if self.event_type() == EventType::MonitorPowerStopEvent {
      self.event().map(MonitorPowerStopEvent::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Event<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<EventType, _>("event_type", Self::VT_EVENT_TYPE, "event", Self::VT_EVENT, false, |key, v, pos| {
        match key {
          EventType::NewImageEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NewImageEvent>>("EventType::NewImageEvent", pos),
          EventType::ImageReceivedEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ImageReceivedEvent>>("EventType::ImageReceivedEvent", pos),
          EventType::ImageScoredEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ImageScoredEvent>>("EventType::ImageScoredEvent", pos),
          EventType::ImageStoredEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ImageStoredEvent>>("EventType::ImageStoredEvent", pos),
          EventType::ImageDeletedEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ImageDeletedEvent>>("EventType::ImageDeletedEvent", pos),
          EventType::PluginStartedEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PluginStartedEvent>>("EventType::PluginStartedEvent", pos),
          EventType::PluginTerminatingEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PluginTerminatingEvent>>("EventType::PluginTerminatingEvent", pos),
          EventType::PluginTerminateEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PluginTerminateEvent>>("EventType::PluginTerminateEvent", pos),
          EventType::MonitorPowerStartEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MonitorPowerStartEvent>>("EventType::MonitorPowerStartEvent", pos),
          EventType::MonitorPowerStopEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MonitorPowerStopEvent>>("EventType::MonitorPowerStopEvent", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct EventArgs {
    pub event_type: EventType,
    pub event: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for EventArgs {
  #[inline]
  fn default() -> Self {
    EventArgs {
      event_type: EventType::NONE,
      event: None,
    }
  }
}

pub struct EventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EventBuilder<'a, 'b> {
  #[inline]
  pub fn add_event_type(&mut self, event_type: EventType) {
    self.fbb_.push_slot::<EventType>(Event::VT_EVENT_TYPE, event_type, EventType::NONE);
  }
  #[inline]
  pub fn add_event(&mut self, event: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Event::VT_EVENT, event);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Event<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Event<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Event");
      ds.field("event_type", &self.event_type());
      match self.event_type() {
        EventType::NewImageEvent => {
          if let Some(x) = self.event_as_new_image_event() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventType::ImageReceivedEvent => {
          if let Some(x) = self.event_as_image_received_event() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventType::ImageScoredEvent => {
          if let Some(x) = self.event_as_image_scored_event() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventType::ImageStoredEvent => {
          if let Some(x) = self.event_as_image_stored_event() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventType::ImageDeletedEvent => {
          if let Some(x) = self.event_as_image_deleted_event() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventType::PluginStartedEvent => {
          if let Some(x) = self.event_as_plugin_started_event() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventType::PluginTerminatingEvent => {
          if let Some(x) = self.event_as_plugin_terminating_event() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventType::PluginTerminateEvent => {
          if let Some(x) = self.event_as_plugin_terminate_event() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventType::MonitorPowerStartEvent => {
          if let Some(x) = self.event_as_monitor_power_start_event() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventType::MonitorPowerStopEvent => {
          if let Some(x) = self.event_as_monitor_power_stop_event() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("event", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_event<'a>(buf: &'a [u8]) -> Event<'a> {
  unsafe { flatbuffers::root_unchecked::<Event<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_event<'a>(buf: &'a [u8]) -> Event<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<Event<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `Event`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_event_unchecked`.
pub fn root_as_event(buf: &[u8]) -> Result<Event, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Event>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Event` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_event_unchecked`.
pub fn size_prefixed_root_as_event(buf: &[u8]) -> Result<Event, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Event>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Event` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_event_unchecked`.
pub fn root_as_event_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Event<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Event<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Event` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_event_unchecked`.
pub fn size_prefixed_root_as_event_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Event<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Event<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Event and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Event`.
pub unsafe fn root_as_event_unchecked(buf: &[u8]) -> Event {
  flatbuffers::root_unchecked::<Event>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Event and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Event`.
pub unsafe fn size_prefixed_root_as_event_unchecked(buf: &[u8]) -> Event {
  flatbuffers::size_prefixed_root_unchecked::<Event>(buf)
}
#[inline]
pub fn finish_event_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Event<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_event_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Event<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod gen_events

